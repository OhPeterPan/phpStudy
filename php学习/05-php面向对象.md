# 类
## 类的定义
	语法格式：class ClassName{}
	只有 成员属性(普通变量，必须带访问修饰符) 和 成员方法(普通函数,可以不需要访问修饰符，默认是public)  类中无法定义常量

	权限修饰符：  成员属性必须添加权限修饰符
		1. public(公共权限): 类内部，类外面、子类中都可以访问
		2. private(私有权限): 只能在类内部访问，类外部和子类中不可以访问
		3. protected(受保护的权限): 本类和子类使用，类外部不能使用

	对象的实例化：关键字 new

	属性的访问：  '->' $对象名->属性名(不带$符号)使用成员属性或者方法  $对象名->方法

	对象可以添加新属性  $对象->不存在的属性   跟js很相似

	使用unset()可以删除变量、属性、数组.....

	类常量：属于类不属于对象，内存中只有一份，被所有对象共享；类常量没有权限
	类常量的定义：const 关键字  定义的是局部常量，只能在局部作用域下使用
				define();定义的是全局常量
				常量一定有值；没有权限修饰符
	类常量访问：ClassName::常量名;静态调用   类名直接访问  谁的属性谁调用，类的属性类自己调用，对象的属性对象自己调用
	类常量对象不支持调用，只能类调用

	构造方法格式：void __construct(); php中只能有一个构造方法

	析构方法：对象销毁前自动调用的方法，void __destruct(void); 
	不带任何参数，垃圾回收工作

	对象销毁时机：网页执行完毕后被销毁；使用unset()方法销毁对象

	静态属性和静态方法：关键字static   静态属性的调用：类名::$静态属性名;  类常量不需要$符号
	属于类的东西(常量、静态变量、静态方法)调用：类名::类的东西
	对象只能调用静态方法，不能调用静态属性!!!!!

	self关键字：指向当前类的指针；用来调用类所属(谨记类所属)属性和方法(类常量，静态变量，静态方法)；self可以用在成员方法与静态方法里  语法格式:self::类常量|静态变量|静态方法|成员方法 不能使用'->'

	$this只能在成员方法中使用，静态方法中不存在；
	很正常的逻辑：类文件被加载时，静态属性和方法已经存在，所以此时不能使用$this，self是指向类的指针

## 内存分配
	var_dump();打印对象时只能打印对象的属性，因为只打印堆中的内存 emmmmm....

	内存分配：栈空间、堆空间、静态空间、代码空间

## 值传递
	整型、字符型、浮点型、NULL、数组、布尔型
	
	注：内存地址都是16进制的数据表示

## 引用传递
	对象和资源

## 类的继承
	为了类功能的升级和扩展(面向修改关闭，面向扩展开放)
	继承关键字  extends

## parent关键字
	代表父类
	语法格式:parent::父类常量|父类静态属性|父类静态方法|父类成员方法

## 类的多态
	php不支持方法重载，一个类中不能有同名的两个方法
	php支持方法重写

## 最终类与最终方法
	关键字：final   
	修饰的类叫最终类，不能继承
	修饰的方法叫最终方法，不能重写

## 抽象类和抽象方法
	关键字：abstract
	抽象类不能直接实例化，需要先继承

## 接口 
	关键字：interface，implements

## 类的自动加载
	spl_autoload_register([callback $auto_load]);
	1. 何时调用
		当试图使用未定义的类时，使用此函数自动加载

## 对象克隆
	关键字：clone 
	使用：clone 对象
	魔术方法__clone();  自动调用(当对象被克隆的时候，自动执行的方法)

## foreach
	可以遍历数组，也可以遍历对象的成员属性(方法,类常量，静态属性均不可以被遍历)

## __toString() 
	跟java中的差不多，可以自定义，使用echo输出对象的时候自动调用

## __invoke();
	把一个对象当前函数调用  对象();  自动调用__invoke();

## php重载
	就是动态的创建类属性和方法
	当调用当前环境下未定义或者不可见的属性或者方法时，重载方法就会被调用
	重载方法都使用'public'

	1. __get();  调用不可访问的属性时，就会调用该魔术方法  public function __get($n){} //$n就是你要的私有属性
	
	2. __set(string $key,string $name);  设置不可访问的属性值时，调用该魔术方法// public function __set($v,$n){} //方法可以有参数  代表属性与值
	
	3. __isset(string $name);对不可访问的属性调用isset()或者empty()时，自动调用这个方法 public function __isset($n){}//$n 使用的属性
	
	4. __unset(string $name);对不可访问的属性调用unset()时，自动调用这个方法 
	
	5. __call(string $name,array $argument);调用不存在的方法时，该魔术方法调用  $name 方法名字 $argument 方法参数数组

	6. __callStatic(string $name,array $argument);静态方式调用不存在的方法时，该魔术方法调用
	
## 序列化 变量离开内存就不是变量了
	1. 序列化
		将变量转化为可保存或者可传输的字符串的过程
		序列化函数 serialize(mixed $value)

	2. 反序列化
		字符串转化为变量
		反序列化函数：unserialize(string $value);

## 对象序列化
	只能序列化成员属性
	序列化的时候有一个魔术方法会调用(如果存在的话) __sleep();

## 对象反序列化
	存在__wakeup()就会调用，常用来做初始化工作;

## 获取静态化方式调用的类名
	静态方法里使用  get_called_class();

	sys_get_temp_dir();//获取系统临时文件目录



	
